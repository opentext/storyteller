StoryTeller in WebAssembly
==========================

This document aims to discuss technical aspects and possible benefits of porting *Document Platform*
to [WebAssembly](http://webassembly.org), low-level bytecode format for in-browser client-side scripting. 

## Table of Contents

  * [WebAssembly](#webassembly)
  * [Tutorials &amp; Examples](#tutorials--examples)
  * [Technical Details](#technical-details)
  * [Attempt #1 - Emscripten](#attempt-1---emscripten)
     * [Prepare the environment](#prepare-the-environment)
     * [Build application code](#build-application-code)
     * [Dynamic libraries](#dynamic-libraries)
     * [32-bit vs. 64-bit](#32-bit-vs-64-bit)
  * [Attempt #2 - Clang 6.0](#attempt-2---clang-60)
     * [Prepare the environment](#prepare-the-environment-1)
     * [Build code](#build-code)
     * [Setup toolchain](#setup-toolchain)
        * [LLD Linker](#lld-linker)
        * [Binaryen](#binaryen)
        * [CMake configuration](#cmake-configuration)

## WebAssembly

*WebAssembly* is a portable stack machine which is designed to be faster to parse than *Javascript*
as well as faster to execute. Its initial aim is to support compilation from *C* and *C++*.

*WebAssembly* evolved from [asm.js](https://en.wikipedia.org/wiki/Asm.js) an intermediate programming
language (a strict subset of *Javascript*) designed to allow programs written in *C/C++* to be run
as web applications while maintaining performance considerably better than standard *Javascript*,
the typical language used for such applications.

*Asm.js* is typically generated by [Emscripten](https://en.wikipedia.org/wiki/Emscripten) which is
a source-to-source compiler (runs as a back end to [LLVM](https://en.wikipedia.org/wiki/LLVM) compiler).

*Asm.js* toolchain typically looks as follows:

    C++ => LLVM => Emscripten => JS

*WebAssembly* can be considered as "asm.js done right". It is a binary executable format for the web,
new web standard created by multi-ventor cooperation (*Google*, *Mozilla*, *Microsoft*, *Apple*, ...).

It is supported by several modern browsers:

  - *Google Chrome*
  - *Chromium*
  - *Mozilla Firefox*
  - *Microsoft Edge*
  - *Opera*

## Tutorials & Examples

  - Video
    - [WebAssembly: A game changer for the Web](https://www.youtube.com/watch?v=MaJCfdmr9Wg)
    - [Compiling for the Web with WebAssembly](https://www.youtube.com/watch?v=6v4E6oksar0)
    - [Advanced JS performance with V8 and Web Assembly](https://www.youtube.com/watch?v=PvZdTZ1Nl5o)
	- [WebAssebmly in Action](https://www.youtube.com/watch?v=DKHuEkmsx3M)
	- [Unreal Engine 3 in Firefox with asm.js](https://www.youtube.com/watch?v=BV32Cs_CMqo&t=24s)
  - Tutorials
    - [Getting Started with WebAssembly](https://tutorialzine.com/2017/06/getting-started-with-web-assembly)
    - [An Abridged Cartoon Introduction To WebAssembly](https://www.smashingmagazine.com/2017/05/abridged-cartoon-introduction-webassembly/)
  - Demos
    - [Tanks demo](http://webassembly.org/demo/)
    - [WebAssembly Video Editor](https://d2jta7o2zej4pf.cloudfront.net/)
    - [Emscripten Examples](https://github.com/kripken/emscripten/wiki/Porting-Examples-and-Demos)
    - [Pdfium in asm.js](http://coolwanglu.github.io/PDFium.js/)
  
## Technical Details

As soon as everyone agreed on a common approach, two parallel efforts begun:

1. There is a temporary hack able to create WebAssembly from asm.js -
   the [asm2wasm](https://github.com/WebAssembly/binaryen/blob/master/src/asm2wasm.h), part of
   [Binaryen](https://github.com/WebAssembly/binaryen) a *WebAssembly* infrastructure library written in *C++*.

   The resulting toolchain looks as follows:

          C++ => LLVM => Emscripten => asm.js => asm2wasm => WebAssembly

2. The long term and more "correct" approach - several compilers are being worked on:

   - New *WebAssembly* backend in *LLVM* (upstream [clang](https://clang.llvm.org/) )
   - [ilwasm](https://github.com/kg/ilwasm) for [.NET CIL](https://en.wikipedia.org/wiki/Common_Intermediate_Language)

Now we are going to describe both variants in more detail:

## Attempt #1 - Emscripten

First we decided to try a more hackish approach - *Emscripten*.
It has a longer tradition and there exists much more documentation, unfortunately the majority
of the documentation deals with *Asm.js*, not with *WebAssembly*.

*Emscripten's WebAssembly* support depends on *Binaryen*, compiler infrastructure
and toolchain library for *WebAssembly*.

More details about generating *WebAssembly* from /Emscripten/ are described
[here](https://github.com/kripken/emscripten/wiki/WebAssembly).

### Prepare the environment

First we need to compile *Emscripten* from source.
The method is described in detail [here](https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm):

```bash
# clone the Emscripten SDK
$ git clone https://github.com/juj/emsdk.git
$ cd emsdk

# Build, install and activate 
$ ./emsdk install --build=Release sdk-incoming-64bit binaryen-master-64bit
$ ./emsdk activate --global --build=Release sdk-incoming-64bit binaryen-master-64bit
```

### Build application code

Now from inside the `emsdk` directory, enter the following command to enter an Emscripten compiler environment
from which you can compile C examples to `asm.js`/`wasm`:

```bash
# prepare environment
$ source ./emsdk_env.sh
# compile a single source code to wasm along with a simple HTML page to run our code in
$ emcc example.c -s WASM=1 -o example.html
```

Now we are almost ready to compile our code with *Emscripten*. We just have to use a modified
*CMake* toolchain. The toolchain file cen be downloaded from
[this link](https://github.com/kripken/emscripten/blob/master/cmake/Modules/Platform/Emscripten.cmake).

In `cmake.sh` we reconfigure the commandline to use the toolchain:

```bash
cmake \
    -D CMAKE_TOOLCHAIN_FILE=$STRS_ROOT/tools/cmake-modules/Emscripten.cmake \
    ...
```

... and use the `-s WASM=1` argument to compiler.


### Dynamic libraries

During the build we get the following warning:

```
WARNING:
	ignoring dynamic library libstrsstd.so because not compiling to JS or HTML,
	remember to link it when compiling to JS or HTML at the end

	Dynamic libraries (.so, .dylib, .dll) are currently not supported by Emscripten.
	For build system emulation purposes, Emscripten will now generate a static
	library file (.bc) with the suffix '.so'. For best practices, please adapt
	your build system to directly generate a static LLVM bitcode library by setting
	the output suffix to '.bc.')
```

So the problem here is that *Emscripten* does not fully support dynamic libraries yet.
It is possible to make a something, which corresponds to a static linking - build
individual libraries separately to `.bc` file and then combine all the bitcode files
to a single result as is described
[here](https://kripken.github.io/emscripten-site/docs/compiling/Building-Projects.html#using-libraries):

```bash
# Generate bitcode files project.bc and libstuff.bc
...

# Link together the bitcode files
$ emcc project.bc libstuff.bc -o allproject.bc

# Compile the combined bitcode to HTML
$ emcc allproject.bc -o final.html
```

It is also described [here](https://kripken.github.io/emscripten-site/docs/compiling/Building-Projects.html#dynamic-linking)
as follows:

> :exclamation: 
> Emscriptenâ€™s goal is to generate the fastest and smallest possible code, and for that reason it focuses
> on generating a single JavaScript file for an entire project. For that reason, dynamic linking should
> be avoided when possible.

But there is also an [experimental support](https://github.com/kripken/emscripten/wiki/Linking)
for true dynamic libraries, loaded as runtime, either via `dlopen` or as a shared library.
See the link for more details.

The *WebAssembly* is designed to support dynamic modules, so the format should support it with no problem.
See the [design document](https://github.com/WebAssembly/design/pull/682) for more details.

### 32-bit vs. 64-bit

During the build we get many compilation warnings regarding the 64-bit to 32-bit shortening.
The problem is that right no the /Emscripten/ is a 32-bit platform, so size_t is a 32-bit
unsigned integer, `__POINTER_WIDTH__=32`, `__SIZEOF_LONG__=4` and `__LONG_MAX__` equals `2147483647L`.

This is because of *Javascript* target, that limitation is not necessary when building to *WebAssembly*.
But so far we did not find a way to switch to a 64-bit build.

## Attempt #2 - Clang 6.0

We tried a second strategy - build a development version of the *clang compiler 6.0*.

### Prepare the environment

The clang 6.0 build method is described [here](https://gist.github.com/yurydelendik/4eeff8248aeb14ce763e)
and [here](https://lld.llvm.org/getting_started.html), and consists of following steps:

```bash
# locations, e.g.
$ export WORKDIR=~/llvmwasm; mkdir -p $WORKDIR
$ export INSTALLDIR=$WORKDIR

# checkout LLVM
$ cd $WORKDIR
$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm

# checkout clang compiler
$ cd $WORKDIR/llvm/tools
$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
# checkout lld linker
$ svn co http://llvm.org/svn/llvm-project/lld/trunk lld

# build folder (~14 min; ~1 hour /wo -j)
$ mkdir $WORKDIR/llvm-build
$ cd $WORKDIR/llvm-build
$ cmake -G "Unix Makefiles" \
   -D CMAKE_INSTALL_PREFIX=$INSTALLDIR \
   -D LLVM_TARGETS_TO_BUILD= \
   -D LLVM_EXPERIMENTAL_TARGETS_TO_BUILD=WebAssembly \
   $WORKDIR/llvm
$ make -j 8

# install llvm
$ make install
```

As the code is under bleeding-edge development, It was necessary to fix two compile errors in `lld`
linker (in [COFF/Driver.cpp](https://github.com/llvm-mirror/lld/blob/master/COFF/Driver.cpp) and
[COFF/DriverUtils.cpp](https://github.com/llvm-mirror/lld/blob/master/COFF/DriverUtils.cpp) files)
but other than that everything was build succesfully.

### Build code

Now we are able to build a simple code example as follows:

```bash
# convert source to LLVM bitcode
$ $INSTALLDIR/bin/clang -emit-llvm --target=wasm64 -Oz example.c -c -o example.bc
# convert LLVM bitcode to WebAssembly
$ $INSTALLDIR/bin/llc -asm-verbose=false -o example.s example.bc
# convert WebAssembly to s-expressions 
$ $BINARYENDIR/bin/s2wasm fib.s > fib.wast
```

But our projects are much more complicated (lots of dynamic libraries) and we are using CMake build system.

In next sections we will try to modify *CMake* configuration.

### Setup toolchain

In `cmake.sh` we reconfigure the commandline to use the toolchain:

```bash
cmake \
    -D CMAKE_TOOLCHAIN_FILE=$STRS_ROOT/tools/cmake-modules/WebAssembly.cmake \
    ...
```

If we try to run *CMake* configuration we get the following error:

```bash
$ ./tools/scripts/cmake-all.sh Debug ubuntu

...
~/streamserve/coreplatform/build/cmake ~/streamserve
* external libs: modern
~/streamserve/.external ~/streamserve/coreplatform/build/cmake ~/streamserve
~/streamserve/coreplatform/build/cmake ~/streamserve
-- The C compiler identification is Clang 6.0.0
-- The CXX compiler identification is Clang 6.0.0
-- Check for working C compiler: ~/llvmwasm/bin/clang
-- Check for working C compiler: ~/llvmwasm/bin/clang -- broken
CMake Error at /usr/share/cmake-3.5/Modules/CMakeTestCCompiler.cmake:61 (message):
  The C compiler "~/llvmwasm/bin/clang" is not able to compile a
    simple test program.

  It fails with the following output:
   Change Dir: ~/streamserve/coreplatform/build/cmake/CMakeFiles/CMakeTmp

  Run Build Command:"/usr/bin/make" "cmTC_36111/fast"
  /usr/bin/make -f CMakeFiles/cmTC_36111.dir/build.make CMakeFiles/cmTC_36111.dir/build
  make[1]: Entering directory '~/streamserve/coreplatform/build/cmake/CMakeFiles/CMakeTmp'
  Building C object CMakeFiles/cmTC_36111.dir/testCCompiler.c.o

  ~/llvmwasm/bin/clang --target=wasm64-unknown-unknown-wasm
     -o CMakeFiles/cmTC_36111.dir/testCCompiler.c.o
     -c ~/streamserve/coreplatform/build/cmake/CMakeFiles/CMakeTmp/testCCompiler.c

  Linking C executable cmTC_36111
  /usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_36111.dir/link.txt --verbose=1
  ~/llvmwasm/bin/clang --target=wasm64-unknown-unknown-wasm
    CMakeFiles/cmTC_36111.dir/testCCompiler.c.o -o cmTC_36111 -rdynamic

  Unknown flavor: wasm

  clang-6.0: error: lld command failed with exit code 1 (use -v to see invocation)
  CMakeFiles/cmTC_36111.dir/build.make:97: recipe for target 'cmTC_36111' failed
  make[1]: *** [cmTC_36111] Error 1
  make[1]: Leaving directory '~/streamserve/coreplatform/build/cmake/CMakeFiles/CMakeTmp'
  Makefile:126: recipe for target 'cmTC_36111/fast' failed
  make: *** [cmTC_36111/fast] Error 2
```

So the importatn message here is the:
```
  Unknown flavor: wasm
```
... it means that the `lld` version of the linker does not support `wasm` flavor.

It seems that we have to look for an updated version of LLD.

#### LLD Linker

In previous section we found out that original version of the
[LLVM lld linker](https://github.com/llvm-mirror/lld.git) does not support the `wasm` flavor yet.

Fortunately there is an updated version in the [WebAssembly lld](https://github.com/WebAssembly/lld.git)
github repository.

So instead of:

```bash
$ git clone https://github.com/llvm-mirror/lld.git
```
... we use the updated version:

```bash
$ git clone https://github.com/WebAssembly/lld.git
$ git checkout wasm
```

And try to build it.

The *LLVM* branch we checked out previously and the updated `lld` version were not in sync and so
we had to fix several compilation errors. Fortunately it was not that hard.

This [patch](https://github.com/opentext/storyteller/blob/master/docs/wasm/lld-build-fix.diff) fixes all the build errors. 

#### Binaryen

We also tried to clone and build [Binaryen](https://github.com/WebAssembly/binaryen.git) tool:

```bash
$ git clone https://github.com/WebAssembly/binaryen.git
$ cd binaryen
$ cmake -DCMAKE_EXE_LINKER_FLAGS="-fuse-ld=gold" \
        -DCMAKE_SHARED_LINKER_FLAGS="-fuse-ld=gold" \
	    -DCMAKE_BUILD_TYPE=MinSizeRel \
	    -DCMAKE_INSTALL_PREFIX=$INSTALLDIR
	  .
$ make -j8
$ make install
```

#### CMake configuration

Now we are able to compile and link a simple code as folows:

```bash
echo "int main(int argc, char* argv[]) { (void)argv; return argc-1;}" > /tmp/testCompiler.c
$ ~/llvmwasm/bin/clang --target=wasm64-unknown-unknown-wasm1  /tmp/testCompiler.c.o
    -o /tmp/testCompiler -rdynamic
$ ~/llvmwasm/bin/lld -flavor wasm /tmp/testCompiler.c.o -entry=main
    -o /tmp/testCompiler.c.o.wasm
```

Unfortunately we still are not able to link dynamic libraries:

```bash
$ ~/llvmwasm/bin/clang --target=wasm64-unknown-unknown-wasm  /tmp/testCompiler.c.o
    -o /tmp/testCompiler.c.o.wasm -rdynamic -v
clang version 6.0.0 (trunk 311084)
Target: wasm64-unknown-unknown-wasm
Thread model: posix
InstalledDir: $HOME/llvmwasm/bin
 "~/llvmwasm/bin/lld" -flavor wasm -export-dynamic -L/lib crt1.o crti.o /tmp/testCompiler.c.o
     -allow-undefined-file wasm.syms -lc -lcompiler_rt crtn.o -o /tmp/testCompiler.c.o.wasm
 ~/llvmwasm/bin/lld: error: cannot open wasm.syms: No such file or directory
 ~/llvmwasm/bin/lld: error: cannot open crt1.o: No such file or directory
 ~/llvmwasm/bin/lld: error: cannot open crti.o: No such file or directory
 ~/llvmwasm/bin/lld: error: unable to find library -lc
 ~/llvmwasm/bin/lld: error: unable to find library -lcompiler_rt
 ~/llvmwasm/bin/lld: error: cannot open crtn.o: No such file or directory
 clang-6.0: error: lld command failed with exit code 1 (use -v to see invocation)
```

The reason seems to be a lack of a system environment for *WebAsssembly* build (C runtime, etc.).

It would be great if we were able to find and download a pre-build environment and use
the
```--sysroot```
argument to point the compiler and linker to it.

Hopefully we'll solve this problem soon.
